#pragma once
#include "output_buffer.hpp"
{% if types_file %}
#include "{{ types_file }}"
{% endif %}

{% if namespace %}
namespace {{ namespace }} {
{% endif %}

struct InputBuffer;
//struct OutputBuffer;

bool ParseBool(InputBuffer& buf, bool* res);
bool ParseFloat(InputBuffer& buf, float* res);
bool ParseVec2(InputBuffer& buf, vec2* res);
bool ParseMat2(InputBuffer& buf, mat2* res);
bool ParseInt(InputBuffer& buf, int* res);
bool ParseString(InputBuffer& buf, string* res);
bool ParseIdentifier(InputBuffer& buf, string* res);

void Serialize(OutputBuffer& buffer, bool value);
void Serialize(OutputBuffer& buffer, int value);
void Serialize(OutputBuffer& buffer, float value);
void Serialize(OutputBuffer& buffer, const string& value);
void Serialize(OutputBuffer& buffer, const vec2& value);
void Serialize(OutputBuffer& buffer, const mat2& value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, bool value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, int value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, float value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, const string& value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, const vec2& value);
void Serialize(OutputBuffer& buffer, int indent, const char* member, const mat2& value);

template <typename T>
void Serialize(OutputBuffer& buffer, int indent, const char* member, const vector<T>& value)
{
  int len = strlen(member);
  buffer.EnsureCapacity(len + indent + 16 + 8 * value.size());
  buffer._ofs += sprintf(buffer.Cur(), "%*s: [", len + indent, member);
  for (size_t i = 0, e = value.size(); i < e; ++i)
  {
    Serialize(buffer, value[i]);
    if (i != e - 1)
    {
      buffer._ofs += sprintf(buffer.Cur(), ", ");
    }
  }
  buffer._ofs += sprintf(buffer.Cur(), "];\n");
}

{% if namespace %}
}
{% endif %}
